apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ .Values.name }}-backup-verify
  namespace: {{ .Values.namespace }}
spec:
  schedule: {{ .Values.backup.verify.schedule | quote }}
  concurrencyPolicy: {{ .Values.backup.concurrencyPolicy }}
  jobTemplate:
    spec:
      ttlSecondsAfterFinished: {{ .Values.backup.ttlSecondsAfterFinished }}
      backoffLimit: {{ .Values.backup.backoffLimit }}
      template:
        spec:
          shareProcessNamespace: true
          containers:
            - name: verify-backup
              image: postgres:{{ .Values.backup.database.postgresVersion }}-alpine
              command: ["/bin/sh", "-c"]
              args:
                - |
                  set -e

                  apk add --no-cache aws-cli curl

                  export AWS_ACCESS_KEY_ID=$S3_ACCESS_KEY_ID
                  export AWS_SECRET_ACCESS_KEY=$S3_SECRET_ACCESS_KEY
                  export AWS_DEFAULT_REGION=$S3_REGION

                  until pg_isready; do
                    sleep 2
                  done

                  S3_URI="s3://${DESTINATION_PATH}"

                  LATEST_BACKUP=$(aws --endpoint-url https://${S3_ENDPOINT} s3 ls ${S3_URI}/ | sort | tail -n 1 | awk '{print $4}')
                  if [ -z "$LATEST_BACKUP" ]; then
                    echo "Error: No backup found"
                    exit 1
                  fi

                  echo "Found: ${LATEST_BACKUP}"
                  DOWNLOAD_PATH="/tmp/${LATEST_BACKUP}"

                  aws --endpoint-url https://${S3_ENDPOINT} s3 cp ${S3_URI}/${LATEST_BACKUP} ${DOWNLOAD_PATH}

                  pg_restore --clean --if-exists --no-owner --no-acl -d $PGDATABASE ${DOWNLOAD_PATH}

                  psql -c "{{ .Values.backup.verify.verificationQuery }}"

                  echo "Verification Successful!"
                  rm ${DOWNLOAD_PATH}

                  KEEP_LAST=7

                  ALL_BACKUPS=$(aws --endpoint-url https://${S3_ENDPOINT} s3 ls ${S3_URI}/ | sort)
                  TOTAL_COUNT=$(echo "$ALL_BACKUPS" | wc -l)

                  if [ "$TOTAL_COUNT" -le "$KEEP_LAST" ]; then
                    echo "No cleanup needed (Total: $TOTAL_COUNT)"
                  else
                    DELETE_COUNT=$((TOTAL_COUNT - KEEP_LAST))
                    echo "Deleting $DELETE_COUNT old backups..."

                    FILES_TO_DELETE=$(echo "$ALL_BACKUPS" | head -n $DELETE_COUNT | awk '{print $4}')

                    for FILE in $FILES_TO_DELETE; do
                      aws --endpoint-url https://${S3_ENDPOINT} s3 rm ${S3_URI}/${FILE}
                      echo "Deleted: ${FILE}"
                    done
                  fi

                  if [ -n "$VERIFY_HEARTBEAT_URL" ]; then
                    echo "Sending heartbeat to $VERIFY_HEARTBEAT_URL..."
                    RESPONSE=$(curl -m 10 --retry 5 -sS "$VERIFY_HEARTBEAT_URL")
                    echo "Response body: $RESPONSE"
                  fi

                  pkill -TERM postgres || true
                  sleep 2

              envFrom:
                - secretRef:
                    name: {{ .Values.name }}-backup
              env:
                - name: S3_ENDPOINT
                  value: {{ .Values.backup.b2.endpoint }}
                - name: S3_REGION
                  value: {{ .Values.backup.b2.region }}
                - name: DESTINATION_PATH
                  value: "{{ .Values.backup.b2.bucket }}/{{ .Values.backup.b2.path }}"
                - name: VERIFY_HEARTBEAT_URL
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.name }}-heartbeat
                      key: verify-heartbeat
                - name: PGHOST
                  value: localhost
                - name: PGUSER
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.backup.database.secretName }}
                      key: DATABASE_USER
                - name: PGPASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.backup.database.secretName }}
                      key: DATABASE_PASS
                - name: PGDATABASE
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.backup.database.secretName }}
                      key: DATABASE_NAME

            - name: postgres-sidecar
              image: postgres:{{ .Values.backup.database.postgresVersion }}-alpine
              env:
                - name: POSTGRES_USER
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.backup.database.secretName }}
                      key: DATABASE_USER
                - name: POSTGRES_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.backup.database.secretName }}
                      key: DATABASE_PASS
                - name: POSTGRES_DB
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.backup.database.secretName }}
                      key: DATABASE_NAME

          restartPolicy: OnFailure
